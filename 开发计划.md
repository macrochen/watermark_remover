# 图片去水印 - AI 逐步开发计划

## 总体思路
本项目将创建一个 Web 应用。前端使用 HTML/JS/CSS 让用户上传图片并交互式地选择水印区域；后端使用 Python/Flask 和 OpenCV 接收数据，通过图像修复（Inpainting）技术去除指定区域的水印，最后将处理后的图片返回给前端进行效果对比和下载。

## 详细开发步骤

- [ ] **第一阶段：项目初始化与环境搭建**
  - [ ] 创建一个名为 `app.py` 的文件，作为 Flask 应用的入口。
  - [ ] 创建 `templates` 目录，用于存放 HTML 文件。
  - [ ] 创建 `static` 目录，并在其下创建 `css` 和 `js` 两个子目录。
  - [ ] 在 Python 虚拟环境中，安装 `Flask`, `opencv-python`, `numpy` 依赖。
  - [ ] 执行 `pip freeze > requirements.txt` 命令，生成依赖清单文件。

- [ ] **第二阶段：构建应用基本框架**
  - [ ] 在 `templates` 目录下创建 `index.html` 文件。
  - [ ] 在 `index.html` 中写入基础的 HTML5 骨架，设置标题为“图片去水印工具”，并在 `<head>` 中链接一个尚不存在的 `static/css/style.css` 文件。
  - [ ] 在 `index.html` 的 `<body>` 底部，引入 jQuery 和一个尚不存在的 `static/js/main.js` 文件。
  - [ ] 在 `app.py` 中，编写一个最基本的 Flask 应用，包含一个根路由 `/`，该路由负责渲染并返回 `index.html` 模板。
  - [ ] 在 `app.py` 中，添加 `if __name__ == '__main__':` 代码块，以便能直接运行进行调试。

- [ ] **第三阶段：实现前端页面布局和图片上传**
  - [x] 在 `static/css` 目录下创建 `style.css` 文件，并添加一些基础样式（如居中布局、按钮美化等）。
  - [x] 在 `index.html` 中，添加具体的页面元素：一个用于上传的 `<input type="file">`，一个用于预览原始图片的 `<img>` 标签，一个“去除水印”按钮，以及一个用于展示结果的 `<img>` 标签和一个“下载”按钮。
  - [x] 在 `static/js` 目录下创建 `main.js` 文件。
  - [x] 在 `main.js` 中，编写 JavaScript 代码，实现当用户通过 input 选择了文件后，在预览 `<img>` 标签中显示该图片的本地预览。

- [ ] **第四阶段：实现水印区域选择功能**
  - [x] 在网上找到 `Jcrop` 库的 `jquery.Jcrop.min.js` 和 `jquery.Jcrop.min.css` 文件，分别保存到 `static/js` 和 `static/css` 目录中。
  - [x] 在 `index.html` 中，正确引入 `Jcrop` 的 CSS 和 JS 文件。
  - [x] 在 `main.js` 中，当图片预览加载完成后，初始化 `Jcrop` 插件到预览图上。
  - [x] 编写 `Jcrop` 的回调函数，当用户选择、移动或缩放选区时，将选区的坐标（x, y, width, height）实时保存到全局 JavaScript 变量中。

- [ ] **第五阶段：实现后端核心处理逻辑**
  - [x] 在 `app.py` 中，创建一个新的路由 `/api/remove-watermark`，并限定其只接受 `POST` 请求。
  - [x] 在该路由函数中，编写代码以接收前端发送的图片文件和坐标数据。
  - [x] 使用 `cv2.imdecode()` 和 `numpy.frombuffer()` 将接收到的文件数据读入为 OpenCV 图像对象。
  - [x] 根据接收到的坐标，创建一个与原图大小相同的全黑掩码（Mask），然后将指定的水印区域在掩码上绘制为白色。
  - [x] 调用 `cv2.inpaint()` 函数，传入原图和掩码，生成已去除水印的新图像。
- [x] 使用 `cv2.imencode()` 将处理后的图像编码为原始格式（如 .png 或 .jpg），然后将其转换为 Base64 字符串。
  - [x] 将 Base64 字符串包装在一个 JSON 对象中，例如 `{"status": "success", "image": "data:image/png;base64,..."}`，并将其作为 API 响应返回。

- [x] **第六阶段：完成前后端集成**
  - [x] 在 `main.js` 中，为“去除水印”按钮添加点击事件监听器。
  - [x] 在监听器函数中，创建一个 `FormData` 对象，并将图片文件和存储的坐标变量追加进去。
  - [x] 使用 `jQuery.ajax()` 或 `fetch()` 方法，将 `FormData` 以 `POST` 请求发送到 `/api/remove-watermark` 端点。
  - [x] 在发送请求时，向用户显示一个“处理中...”的提示。
  - [x] 在请求成功的回调函数中，获取返回的 JSON 数据，提取 Base64 字符串，并将其设置为结果 `<img>` 标签的 `src` 属性。
  - [x] 将“下载”按钮的 `href` 属性也设置为该 Base64 字符串，并设置 `download` 属性为一个建议的文件名（如 `processed.png`），然后使其可见或可用。

- [ ] **第七阶段：实现手动裁剪功能 (新增)**
  - [x] 在 `index.html` 中，添加“效果不佳？尝试手动裁剪”和“确认裁剪”按钮，并默认隐藏它们。
  - [x] 在 `main.js` 中，引入一个变量来管理当前的应用模式（例如 `let currentMode = 'inpaint';`）。
  - [x] 在 `main.js` 的 AJAX 成功回调中，显示“效果不佳？尝试手动裁剪”按钮。
  - [x] 为“尝试手动裁剪”按钮绑定点击事件。点击后，切换应用模式为 `crop`，更新指引文本，并重置 Cropper.js 实例以允许用户进行新的选择。
  - [x] 修改主操作按钮（原“去除水印”按钮）的逻辑：根据当前模式，其文本和功能在“去除水印”和“确认裁剪”之间切换。
  - [x] 实现“确认裁剪”的逻辑：点击后，使用 Cropper.js 的 `getCroppedCanvas()` 方法在前端生成裁剪后的图片，并将其显示在结果区和更新下载链接。
